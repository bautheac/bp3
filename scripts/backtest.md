Load
----

I load the data into two dataframes here; one for historical data
(“data\_price\_etf.csv” in the original github repo) and one for
qualitative data (“data\_static\_etf\_com.csv” in the original github
repo).

``` r
historic <- readr::read_csv(file = "../data/data_historic_etf.csv") %>%
  dplyr::mutate(Date = as.Date(Date)) %>% dplyr::arrange(Date) %>%
  tidyr::gather(`name`, price, -Date) %>% dplyr::mutate(price = as.numeric(price)) %>% 
  dplyr::filter(complete.cases(.))
static <- readr::read_csv(file = "../data/data_static_etf.csv")
```

Transform
---------

To my understanding, feature engineering here involves calculating
statistics as well as constructing TDA feature(s?) at regular interval
(monthly) from the time series data at regular interval (monthly). The
resulting dataframe would contain, for each month, one sample per name
(ETF) where features include time series statistics, TDA value(s?) as
well as qualitative information (static dataframe).

### Historic features

I understand that time series statistics include return, high minus low
as well as volatility over various time horizons including past week,
past 4 weeks, past 8 weeks, past 13 weeks, past 26 weeks, past 52 weeks.

#### Returns

I calculate returns as the relative change in price over the
above-mentioned time horizons here.

``` r
sizes <- dplyr::group_by(historic, `name`) %>% dplyr::summarise(n = n())

historic %<>% dplyr::group_by(`name`) %>% dplyr::left_join(sizes, by = "name") %>%
  dplyr::mutate(
    `return - 1w` = price / dplyr::lag(price, n = 1L) - 1L,
    `return - 4w` = price / dplyr::lag(price, n = 4L) - 1L,
    `return - 8w` = price / dplyr::lag(price, n = 8L) - 1L,
    `return - 13w` = price / dplyr::lag(price, n = 13L) - 1L,
    `return - 26w` = price / dplyr::lag(price, n = 26L) - 1L,
    `return - 52w` = price / dplyr::lag(price, n = 52L) - 1L
    )

remove(sizes)
```

#### High - low

I calculate high minus low by substracting the minimum observed value
from the maximum observed value over the above-mentioned time horizons
here.

``` r
`high - low` <- function(x) max(x) - min(x)

`high - low - 4w` <- tibbletime::rollify(`high - low`, window = 4L)
`high - low - 8w` <- tibbletime::rollify(`high - low`, window = 8L)
`high - low - 13w` <- tibbletime::rollify(`high - low`, window = 13L)
`high - low - 26w` <- tibbletime::rollify(`high - low`, window = 26L)
`high - low - 52w` <- tibbletime::rollify(`high - low`, window = 52L)

historic %<>% dplyr::mutate(
  `high - low - 4w` = `high - low - 4w`(price),
  `high - low - 8w` = `high - low - 8w`(price),
  `high - low - 13w` = `high - low - 13w`(price),
  `high - low - 26w` = ifelse(`n` > 26L, `high - low - 26w`(price), NA),
  `high - low - 52w` = ifelse(`n` > 52L, `high - low - 52w`(price), NA)
  )

remove(`high - low`, `high - low - 4w`, `high - low - 8w`, 
       `high - low - 13w`, `high - low - 26w`, `high - low - 52w`)
```

#### Volatility

I calculate volatility as the annualized standard deviation of 1-week
returns over the above-mentioned time horizons here.

``` r
`volatility` <- function(x) sd(x, na.rm = T) * sqrt(52L)

`volatility - 4w` <- tibbletime::rollify(`volatility`, window = 4L)
`volatility - 8w` <- tibbletime::rollify(`volatility`, window = 8L)
`volatility - 13w` <- tibbletime::rollify(`volatility`, window = 13L)
`volatility - 26w` <- tibbletime::rollify(`volatility`, window = 26L)
`volatility - 52w` <- tibbletime::rollify(`volatility`, window = 52L)

historic %<>% dplyr::mutate(
  `volatility - 4w` = `volatility - 4w`(`return - 1w`),
  `volatility - 8w` = `volatility - 8w`(`return - 1w`),
  `volatility - 13w` = `volatility - 13w`(`return - 1w`),
  `volatility - 26w` = ifelse(`n` > 26L, `volatility - 26w`(`return - 1w`), NA),
  `volatility - 52w` = ifelse(`n` > 52L, `volatility - 52w`(`return - 1w`), NA)
  )

remove(`volatility`, `volatility - 4w`, `volatility - 8w`, 
       `volatility - 13w`, `volatility - 26w`, `volatility - 52w`)
saveRDS(historic, file = "../data/historic.rds")
```

#### TDA

I get stuck here. To my undertanding there should be TDA feature(s?) for
every month and name with the feature(s?) generated by feeding the
previous 52-week price history to TDA functions. The output dataset in
the original github repo shows 100 values (columns) for each name (row):

``` r
tibble::as.tibble(read.csv("../data/TDA_features_tr.csv"))
```

    #> # A tibble: 41,112 x 102
    #>        X V1       V2      V3     V4     V5      V6     V7     V8     V9
    #>    <int> <fct> <int>   <dbl>  <dbl>  <dbl>   <dbl>  <dbl>  <dbl>  <dbl>
    #>  1     1 ADRA      0 0.471   0.941  1.41   1.88    2.35   2.82   3.29  
    #>  2     2 ADRD      0 0.478   0.567  0.0886 0       0.284  0.763  1.24  
    #>  3     3 ADRE      0 0.732   1.46   2.20   2.93    3.66   3.68   2.94  
    #>  4     4 ADRU      0 0.557   0.124  0      0       0.358  0.915  1.47  
    #>  5     5 AGG       0 0.109   0.218  0.261  0.152   0.0428 0      0.0333
    #>  6     6 AUSE      0 0.637   1.20   1.23   1.87    2.51   3.14   3.78  
    #>  7     7 AXJL      0 0.707   1.41   2.12   2.83    3.53   4.24   3.76  
    #>  8     8 BIL       0 0.00977 0.0195 0.0293 0.0391  0.0488 0.0586 0.0684
    #>  9     9 BIV       0 0.150   0.300  0.154  0.00356 0      0      0     
    #> 10    10 BLV       0 0.141   0.282  0.423  0.564   0.705  0.588  0.729 
    #> # ... with 41,102 more rows, and 92 more variables: V10 <dbl>, V11 <dbl>,
    #> #   V12 <dbl>, V13 <dbl>, V14 <dbl>, V15 <dbl>, V16 <dbl>, V17 <dbl>,
    #> #   V18 <dbl>, V19 <dbl>, V20 <dbl>, V21 <dbl>, V22 <dbl>, V23 <dbl>,
    #> #   V24 <dbl>, V25 <dbl>, V26 <dbl>, V27 <dbl>, V28 <dbl>, V29 <dbl>,
    #> #   V30 <dbl>, V31 <dbl>, V32 <dbl>, V33 <dbl>, V34 <dbl>, V35 <dbl>,
    #> #   V36 <dbl>, V37 <dbl>, V38 <dbl>, V39 <dbl>, V40 <dbl>, V41 <dbl>,
    #> #   V42 <dbl>, V43 <dbl>, V44 <dbl>, V45 <dbl>, V46 <dbl>, V47 <dbl>,
    #> #   V48 <dbl>, V49 <dbl>, V50 <dbl>, V51 <int>, V52 <int>, V53 <dbl>,
    #> #   V54 <dbl>, V55 <dbl>, V56 <dbl>, V57 <dbl>, V58 <dbl>, V59 <dbl>,
    #> #   V60 <dbl>, V61 <dbl>, V62 <dbl>, V63 <dbl>, V64 <dbl>, V65 <dbl>,
    #> #   V66 <dbl>, V67 <dbl>, V68 <dbl>, V69 <dbl>, V70 <dbl>, V71 <dbl>,
    #> #   V72 <dbl>, V73 <dbl>, V74 <dbl>, V75 <dbl>, V76 <dbl>, V77 <dbl>,
    #> #   V78 <dbl>, V79 <dbl>, V80 <dbl>, V81 <dbl>, V82 <dbl>, V83 <dbl>,
    #> #   V84 <dbl>, V85 <dbl>, V86 <dbl>, V87 <dbl>, V88 <dbl>, V89 <dbl>,
    #> #   V90 <dbl>, V91 <dbl>, V92 <dbl>, V93 <dbl>, V94 <dbl>, V95 <dbl>,
    #> #   V96 <dbl>, V97 <dbl>, V98 <dbl>, V99 <dbl>, V100 <dbl>, V101 <int>

Are there 100 TDA features? If so, why is there only 1 set of value(s?),
was expecting TDA values for each month.

#### Wrap up

``` r
historic <- readRDS(file = "../data/historic.rds")
historic %<>% dplyr::mutate(year = lubridate::year(Date), month = lubridate::month(Date), date = Date) %>%
  dplyr::group_by(name, year, month) %>% dplyr::filter(dplyr::row_number() == n()) %>% 
  dplyr::ungroup() %>% dplyr::select(-c("Date", "n", "year", "month")) %>% 
  tidyr::gather(feature, value, -c("date", "name"))
```
